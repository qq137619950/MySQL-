# MySQL-
MySQL学习记录，持续更新。

1.索引与算法

innodb使用B+树
查找一行数据的流程：从B+树中查找被查询行所在的页，然后数据库把页读入内存，然后在内存中进行二分查找。

聚簇索引：按照每张表的主键构造一个b+树，叶子节点存放整张表行的记录数据，称为数据页。查询优化器倾向于采用聚簇索引。
对主键排序查找和范围查找速度快。

show index from 有一个重要的值， Cardinality，表示索引中唯一值的数目的估计值。Cardinality表的行数尽可能接近1，如果比较小，则可考虑删除此索引。

Fast Index Creation：快速索引创建，对表加s锁，会阻塞表上的DML操作。

Online DDL：5.6版本之后新加，在线数据定义。在辅助索引创建的同时，允许DML操作，提高了MySQL数据库在生产环境的可用性。

联合索引：B+树，键值的数量大于1，支持最左匹配原则。另外，对后面的字段也进行了排序，可以无需再做额外的排序工作（要注意场景）。

覆盖索引：从二级索引中直接得到查询的记录。Extra列Using index表示优化器进行了索引覆盖。另外，select count(*) 优化器也可以进行索引覆盖，因为二级索引更小，效率更高。

优化器不选择二级索引的情况：访问数据量大，一般是全表记录数的20%以上，而且没有覆盖，顺序读比回表离散读快。ps. 如果使用ssd等存储介质能够明确二级索引能够带来更好的性能，可以使用 force index 强制使用某个索引。

Multi-Range Read优化：减少磁盘随机访问，将随机访问转化为较为顺序的数据访问。查询二级索引的时候，根据得到的查询结果，按照主键进行排序，同时减少缓冲池页被替换的次数。Extra列Using MRR表示使用了该优化。

Index Condition Pushdown：索引下推，MySQL数据库在取出二级索引的同时，判断是否可以进行where条件过滤，也就是将where的部分过滤放在了存储引擎层。Extra列Using index condition表示使用该优化。


